% !TeX spellcheck = de_DE_frami
% !TEX root = document.tex
\section{Der Greedy-Algorithmus}
Seien $a, b \in \N; b \neq 0$. Eine der bekanntesten Methoden, eine Ägyptische Erweiterungen für Brüche $\frac{a}{b}$ zu finden, ist der Greedy-Algorithmus. Dabei werden jeweils die größtmöglichen Stammbrüche $\frac{1}{x_i}$ gesucht, sodass
\begin{equation}\label{eq:greedy_fracNorm}
\frac{1}{x_i} \leq \frac{a}{b} - \sum_{j=1}^{i-1} \frac{1}{x_j} < \frac{1}{x_{i}-1},
\end{equation}
wobei gilt, dass
$$x_i \neq x_j; \forall i \neq j = (1,..,i)$$ 
\change[inline]{das ist nicht nachvollziehbar!}
solange, bis
$$\frac{a}{b} = \frac{1}{x_1} + \frac{1}{x_2} + ... + \frac{1}{x_i} = \sum_{j=1}^{i} \frac{1}{x_j}.$$
Da in jedem Fall der größtmögliche, noch nicht vorhandene Bruch gesucht wird, der noch in die Summe der Stammbrüche passt, ohne dass diese zu groß wird, kann es zu sehr ungünstigen Ergebnissen mit extrem langen Divisoren kommen; ein anschauliches Beispiel dafür ist:
$$\frac{5}{121} = \uf{25} + \uf{757} + \uf{763309} + \uf{873960180913} + \uf{1527612795642093418846225},$$
wobei man den Bruch auch folgendermaßen zerlegen kann:
$$\frac{5}{121} = \uf{33} + \uf{121} + \uf{363}.$$
Aufgrund dieser Komplexitätsprobleme scheint es unsinnig, den Greedy-Algorithmus zu verwenden. Nichtsdestotrotz lässt sich beweisen, dass der Greedy-Algorithmus immer terminiert.
Im Anhang \ref{code:greedy} findet sich eine eigene Implementierung des Greedy-Algorithmus.

\begin{satz}
	Der Greedy-Algorithmus, wie oben beschrieben, terminiert für jede Eingabe.
\end{satz}
\begin{bew}
	Für die erste Iteration des Greedy-Algorithmus ergibt sich aus \ref{eq:greedy_fracNorm}:
	\begin{equation*}
		\uf{x} \leq \frac{a}{b} < \uf{x-1}
	\end{equation*}
	Daraus folgt ein Rest $r$ von
	$$ r = \frac{a}{b}-\uf{x} = \frac{ax-b}{bx},$$
	der den Zähler $(ax-b)$ hat, \improvement{Beweis einfügen} der kleiner als a ist. \\ Somit verkleinert sich dieser Rest mit jedem Schritt und erreicht irgendwann Null, wie gefordert.
\end{bew}